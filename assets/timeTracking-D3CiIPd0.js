import{f as t,u as e,q as r,d as a,w as o,o as n,e as s,k as i,m as c}from"./firebase-Bz9ybdfi.js";import{f as d}from"./index-SvUTDYpM.js";const u="timeEntries",l="timeSessions";function m(t){return`${t.getFullYear()}-${String(t.getMonth()+1).padStart(2,"0")}-${String(t.getDate()).padStart(2,"0")}`}function w(t){return new Date(t).toLocaleTimeString([],{hour:"2-digit",minute:"2-digit"})}function h(t,e){const r=e-t;return Math.round(r/36e5*100)/100}async function g(t){try{const e=Object.fromEntries(Object.entries({...t,createdAt:Date.now(),updatedAt:Date.now()}).filter(([t,e])=>void 0!==e));return(await i(a(d,u),e)).id}catch(e){throw console.error("Error creating time entry:",e),e}}async function y(r,a){try{const o=t(d,u,r),n=Object.fromEntries(Object.entries({...a,updatedAt:Date.now()}).filter(([t,e])=>void 0!==e));await e(o,n)}catch(o){throw console.error("Error updating time entry:",o),o}}async function f(e){try{await c(t(d,u,e))}catch(r){throw console.error("Error deleting time entry:",r),r}}async function p(t,e,i){try{let c=r(a(d,u),o("userId","==",t),n("date","desc"),n("clockIn","desc"));e&&i&&(c=r(c,o("date",">=",e),o("date","<=",i)));return(await s(c)).docs.map(t=>({id:t.id,...t.data()}))}catch(c){if(c.message&&c.message.includes("index is currently building")){console.warn("Firebase index is still building. Using alternative query method.");try{const n=r(a(d,u),o("userId","==",t));let c=(await s(n)).docs.map(t=>({id:t.id,...t.data()}));return e&&i&&(c=c.filter(t=>t.date>=e&&t.date<=i)),c.sort((t,e)=>{const r=e.date.localeCompare(t.date);return 0!==r?r:e.clockIn-t.clockIn})}catch(l){console.error("Fallback query also failed:",l)}}throw console.error("Error fetching time entries:",c),c}}async function k(t,e){try{const i=r(a(d,u),o("userId","==",t),o("date","==",e),n("clockIn","asc"));return(await s(i)).docs.map(t=>({id:t.id,...t.data()}))}catch(i){if(i.message&&i.message.includes("index is currently building")){console.warn("Firebase index is still building. Using alternative query method.");try{const n=r(a(d,u),o("userId","==",t)),i=await s(n);return i.docs.map(t=>({id:t.id,...t.data()})).filter(t=>t.date===e).sort((t,e)=>t.clockIn-e.clockIn)}catch(c){console.error("Fallback query also failed:",c)}}throw console.error("Error fetching time entries for date:",i),i}}async function I(r){try{const o=await E(r);o&&(console.log("Cleaning up existing active session:",o.id),await e(t(d,l,o.id),{isActive:!1,endTime:Date.now(),totalHours:h(o.startTime,Date.now())}).catch(t=>console.warn("Could not update existing session:",t)));const n={userId:r,startTime:Date.now(),isActive:!0};return(await i(a(d,l),n)).id}catch(o){throw console.error("Error starting time session:",o),o}}async function D(r){try{const a=await E(r);if(!a)throw new Error("No active time session found");const o=Date.now(),n=h(a.startTime,o);await e(t(d,l,a.id),{endTime:o,isActive:!1,totalHours:n});const s={userId:r,date:m(new Date(o)),clockIn:a.startTime,clockOut:o,totalHours:n,isManual:!1};return{id:await g(s),...s,createdAt:o,updatedAt:o}}catch(a){throw console.error("Error stopping time session:",a),a}}async function E(t){try{const e=r(a(d,l),o("userId","==",t),o("isActive","==",!0)),n=await s(e);if(!n.empty){const t=n.docs[0];return{id:t.id,...t.data()}}return null}catch(e){throw console.error("Error fetching active session:",e),e}}async function b(t,e,r,a,o){try{const n=new Date(`${e}T${r}`).getTime(),s=new Date(`${e}T${a}`).getTime();if(s<=n)throw new Error("Clock out time must be after clock in time");const i={userId:t,date:e,clockIn:n,clockOut:s,totalHours:h(n,s),isManual:!0,notes:o};return{id:await g(i),...i,createdAt:Date.now(),updatedAt:Date.now()}}catch(n){throw console.error("Error creating manual time entry:",n),n}}async function v(t){try{const e=new Date,r=m(e),a=new Date(e.getTime()-6048e5),o=new Date(e.getFullYear(),e.getMonth(),1),[n,s,i,c]=await Promise.all([k(t,r),p(t,m(a),r),p(t,m(o),r),E(t)]),d=n.reduce((t,e)=>t+(e.totalHours||0),0),u=s.reduce((t,e)=>t+(e.totalHours||0),0),l=i.reduce((t,e)=>t+(e.totalHours||0),0),w=new Set(i.map(t=>t.date)).size,h=w>0?l/w:0;return{todayHours:Math.round(100*d)/100,weekHours:Math.round(100*u)/100,monthHours:Math.round(100*l)/100,averageDailyHours:Math.round(100*h)/100,currentSession:c||void 0}}catch(e){throw console.error("Error fetching time tracking stats:",e),e}}async function A(t,e,r,a){try{const o=`${a}-${r.padStart(2,"0")}-01`,n=new Date(a,parseInt(r),0),s=`${a}-${r.padStart(2,"0")}-${n.getDate().toString().padStart(2,"0")}`,i=await p(t,o,s),c=i.reduce((t,e)=>t+(e.totalHours||0),0);return{userId:t,userName:e,month:r,year:a,totalHours:Math.round(100*c)/100,dailyEntries:i,generatedAt:Date.now()}}catch(o){throw console.error("Error generating monthly report:",o),o}}async function H(t,e){try{const i=r(a(d,u),o("date",">=",t),o("date","<=",e),n("date","asc"),n("userId","asc")),c=await s(i);return c.docs.map(t=>({id:t.id,...t.data()})).sort((t,e)=>{const r=e.date.localeCompare(t.date);return 0!==r?r:e.clockIn-t.clockIn})}catch(i){if(i.message&&i.message.includes("index")){console.warn("Compound index failed, using simpler query");try{const n=r(a(d,u),o("date",">=",t),o("date","<=",e)),i=await s(n);return i.docs.map(t=>({id:t.id,...t.data()})).sort((t,e)=>{const r=e.date.localeCompare(t.date);return 0!==r?r:e.clockIn-t.clockIn})}catch(c){console.error("Fallback query also failed:",c)}}throw console.error("Error fetching all time entries:",i),i}}async function S(r,a,o){try{const n=Object.fromEntries(Object.entries({...a,updatedAt:Date.now(),updatedBy:o}).filter(([t,e])=>void 0!==e));await e(t(d,u,r),n)}catch(n){throw console.error("Error updating time entry as admin:",n),n}}export{I as a,p as b,A as c,m as d,H as e,w as f,v as g,b as h,f as i,h as j,y as k,D as s,S as u};
